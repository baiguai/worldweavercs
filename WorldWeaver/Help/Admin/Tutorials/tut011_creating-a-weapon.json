{
    "topics" : [
        {
            "pattern" : "\\b(?:tut.creating.a.weapon)\\b",
            "title" : "Creating a Weapon",
            "string" : "
WorldWeaver (WW) was designed to build Role Playing Game (RPG) style games.
You could create traditional book-like Interactive Fiction (IF) games if you want to,
but WW was built with exploring large worlds and fighting enemies in mind.

So let's give our player a weapon.
Our player currently looks something like this:

---

{key=player, name=, type=player, parent=local_pub
    {key=player_life, name=Life, type=attribute, output=[rand:8|18], tags=stats }
    {key=player_strength, name=Strength, type=attribute, output=[rand:8|18], tags=stats }
    {key=player_intelligence, name=Intelligence, type=attribute, output=[rand:8|18], tags=stats }
    {key=player_cunning, name=Cunning, type=attribute, output=[rand:8|18], tags=stats }
    {key=player_gold, name=Gold, type=attribute, output=[rand:20|40], tags=stats }
    {key=player_armed, name=Armed Weapon, type=attribute, output=, tags=armed|stats }

    {key=longsword_01, name=Long Sword, type=weapon, syntax=\b(long sword)\b, tags=inventory
        {name=Damage, type=attribute, logic=[rand:4|12], tags=damage }
    }
}

---

Oh! A weapon is already defined.
You see that there is an element of type 'weapon' in our player's inventory.
It has a syntax specified, so that we can specify it.
And it has an attribute with a random logic (NOT output) value. Because it is the logic
that is random, this number will be changed every time we read the value.
The attribute has a special tag of 'damage'.

So when the player attacks something and hits, random damage will be applied.

!NOTE!
    Attack and damage actions are always defined within the enemy's definition code.
    This allows the messages to pertain to that particular enemy, and what happens when
    attacked or killed can also be specific to it.
    If these aren't defined in the enemey, then the player simply cannot attack it.

To be able to use our weapon, we must 'arm' the player with it.
This way if the player is carrying multiple weapons they can swap one weapon for another.
If this is done during battle, that counts as the player's turn in the conflict.

In our global file, let's add an arm action.
Currently our global file looks like this:

---

{key=global01, type=global, parent=root
    {type=input, syntax=\b(stats)\b
        {type=action, logic=player((stats)), tags=list, output=Stats: }
    }
    {type=input, syntax=\b(inventory|inv)\b
        {type=action, logic=player((inventory)), tags=list, output=Inventory: }
    }
)

---

Now let's add the input and a new element type of 'set' to arm the player:

---

{key=global01, type=global, parent=root
    {type=input, syntax=\b(stats)\b
        {type=action, logic=player((stats)), tags=list, output=Stats: }
    }
    {type=input, syntax=\b(inventory|inv)\b
        {type=action, logic=player((inventory)), tags=list, output=Inventory: }
    }

    {type=input, syntax=\b(arm *)\b
        {type=set, logic=player_armed(output)[input], tags=arm
            {type=message, tag=arm
                output={@
You are now armed with the [field|[input]|name].
                }
            }
        }
    }
}

---

The first thing to note is that the syntax has a wildcard (*) in it.
This is because the user will be specifying the weapon they want to arm.
WW will attempt to make a syntax match to an element using this input value.
If the player's input doesn't match one single element a message will be displayed
letting the player know the game doesn't know what they are referring to.

Next let's look closer at the set element. You'll notice the familiar parenthesis.
However in the context of a set element's logic, it is a bit different.
These specify the field we want to update.

So the set above is designed to set the output of the 'player_armed' attribute.
You may have noticed that in our player, that attribute's output was set to blank.
(We could simply omit that field in the definition)

BUT! The player wouldn't know what the identifying key is of the weapon they are
trying to arm. So WW will attempt to replace the '[input]' with a single matched
key.
It tries to match the users input to a syntax value OR if that fails part of an element's name.

If it finds just one item, the player's 'player_armed' attribute will be set to
that element's key.

So when we're fighting we can reference that attribute to get our weapon.
If it is blank, we can write logic to warn the player that they currently aren't armed
with a weapon.

---

We'll discuss fighting later, you will want to be comfortable with game definition
before tackling that!
",
            "links" : [
                "_help tut about time"
            ]
        }
    ]
}
