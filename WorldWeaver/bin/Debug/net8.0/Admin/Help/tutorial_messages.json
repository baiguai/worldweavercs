{
    "topics" : [
        {
            "pattern" : "\\b(?:tutorial.messages)\\b",
            "title" : "Working with Messages",
            "string" : "
Messages have some unique rules. If you have more than one message as child elements, they
follow the parent's repeat rules. So if you want an element to consider ALL the child messages,
you will want to define an action for each, and those actions will have a single child or set of
message children that will follow its repeat option.

So consider the following. When the player looks around, let's say we want to let them know if
it is day or night. Is day is a built in function. And there is 'inline logic' that can be specified
in a message. (See _help message logic). However this is very limited. There is a more powerful
means of accomplishing this. Within a message, we can use inline logic to point to another element
and its output will be inserted into our message.

For example, we can define an element with the key of 'day_string'. And in this type we want to do a
true check, and a false check, and output text accordingly.

So we will create a global element like so:


{key=day_string
    {type=action
        {type=logic
            logic={@
                ?[isday] = 'false'
            }
        }
        {type=message
            output={@
It is night.

            }
        }
    }

    {type=action
        {type=logic
            logic={@
                ?[isday] = 'true'
            }
        }
        {type=message
            output={@
It is day.

            }
        }
    }
}


And we'll place this within an element of type=global so:


{key=global01, type=global, parent=root
    {type=input, syntax=\b(stats)\b
        {type=action, logic=player|stats, tags=list, output=Stats: }
    }
    {type=input, syntax=\b(inventory|inv)\b
        {type=action, logic=player|inventory, tags=list, output=Inventory: }
    }

    {type=input, syntax=\b(arm *)\b
        {type=set, logic=player_armed|output|[input], tags=arm
            {type=message
                output={@
You are now armed with the [field|longsword_01|name].
                }
            }
        }
    }

    {key=day_string
        {type=action
            {type=logic
                logic={@
                    ?[isday] = 'false'
                }
            }
            {type=message
                output={@
It is night.

                }
            }
        }

        {type=action
            {type=logic
                logic={@
                    ?[isday] = 'true'
                }
            }
            {type=message
                output={@
It is day.

                }
            }
        }
    }
}


Now in our message we can inject the text of the action that passes its logic check:

{key=local_pub, name=Local Pub, type=room, parent=root
    {type=enter_message
        output={@
You are in the pub.
        }
    }

    {type=look
        {type=message
            output={@
You look around the local pub.

[key|day_string]
            }
        }
    }

    {type=input, syntax=\b(look|l)\b
        {type=action, logic=look, tags=type }
    }
}



Our reference to the 'is day' message is a piece of inline logic that looks like this:

[key|day_string]

Key lets the game know that we're referencing an element by its element key.
And after the pipe delimiter we note the key value itself.


You may have noticed that this element's messages are within action elements.
That is because every action is considered. If the action's logic passes, its message
element is fired.
If we were to put just the messages in the day_string element it would follow that
element's repeat options. If there is no repeat option, it will consider the first message,
and the next time it gets hit, the second message.

So unless your messages are repeating, or going down a list of messages, or choosing a random
message, wrap them within action elements.


In this article we've touched on logic. Next we'll dive deeper into what we can do
with logic elements.


_help tutorial logic
"
        }
    ]
}
